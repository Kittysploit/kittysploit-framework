from kittysploit.core.framework.base_module import BaseModule
from kittysploit.core.framework.option import OptInteger, OptPayload, OptString, OptBool
from kittysploit.core.framework.browser_server.base_browser_server import sio
from kittysploit.core.framework.failure import ProcedureError, fail
from kittysploit.core.base.storage import LocalStorage
from kittysploit.core.base.io import print_error, print_status
from kittysploit.core.base.jobs import Jobs
from kittysploit.core.utils.function_module import pythonize_path
import importlib
import socket, errno
import threading
import time

class BrowserExploit(BaseModule):
    
    TYPE_MODULE = "browser_exploit"
    
    session = OptInteger(0, "Session to interact with", required=True)
    payload = OptPayload("", "Payload type", required=True)

    exploit_timeout = OptInteger(20, "Timeout", required=True, advanced=True)
    disablePayloadHandler = OptBool(False, "Disable handler when exploit run", required=False, advanced=True)
    customPayload = OptString("","Execute module with custom payload (no listener start)",required=False,advanced=True,)


    def __init__(self):
        super(BrowserExploit, self).__init__()
        self.job = Jobs()
        self.local_storage = LocalStorage()
        self.current_version = 0
        self._current_payload = None
        self._payload_options = []
        self._waiting_session = True
        self._handler = None

    def run(self):
        raise NotImplementedError("You have to define your own 'run' method.")

    def check(self):
        raise NotImplementedError("You have to define your own 'run' method.")

    def default_options(self):
        return False

    def _execute(self, code):
        """
        :param code: The javascript code
        :return: None
        """
        sio.emit(
            "issue_task",
            {"task_id": int(self.session), "input": code},
            room=self._handler,
            namespace="/remote",
        )
        return ""
    
    def send_js(self, code):
        """
        :param code: The javascript code
        :return: None
        """
        self._execute(code)
    
    def _exploit(self):
        if self._waiting_session:
            if not self._check_session_exist():
                return
            if self._current_payload:
                if "handler" in self._current_payload._Module__info__:
                    if self._check_if_port_busy(self.exploit_attributes["lport"][0]):
                        handler = self._current_payload._Module__info__["handler"]["name"]
                        if handler == "reverse":
                            setattr(self._current_payload,"lhost",self.exploit_attributes["lhost"][0],)
                            setattr(self._current_payload,"lport",self.exploit_attributes["lport"][0],)
                            if not self.disablePayloadHandler:
                                prepare_listener = pythonize_path(self._current_payload._Module__info__["listener"])
                                try:
                                    listener = getattr(importlib.import_module("modules." + prepare_listener),"Module",)()
                                except:
                                    print_error(f"Problem with: {self._current_payload._Module__info__['listener']}")
                                    raise ProcedureError()
                                setattr(listener, "lhost", self.exploit_attributes["lhost"][0])
                                listener.exploit_attributes["lhost"][0] = (self.exploit_attributes["lhost"][0])
                                setattr(listener, "lport", self.exploit_attributes["lport"][0])
                                listener.exploit_attributes["lport"][0] = (self.exploit_attributes["lport"][0])
                                job_process = threading.Thread(target=listener._exploit, args=[])
                                job_process.setDaemon(True)
                                job_process.start()
                                if not self.local_storage.get("exploit_job"):
                                    self.local_storage.set(
                                        "exploit_job",
                                        {"listener": listener, "thread": job_process},
                                    )
                                time.sleep(1)

                            self.run()
                            print_status("Wait session...")
                            start_time = time.time()
                            while time.time() - start_time < self.exploit_timeout:
                                if LocalStorage().get(f"session_found") == True:
                                    LocalStorage().delete("session_found")
                                    return True
                                time.sleep(0.5)
                            time.sleep(0.5)
                            if self.local_storage.get(f"session_found") == None:
                                fail.NoSession
        else:
            if self._waiting_session:
                if not self._check_session_exist():
                    return
            self.run()
    
    def _check_session_exist(self):
        _sessions = self.local_storage.get("sessions")
        if not self.session in _sessions:
            print_error("Session not found")
            return False
        return True

    def _check_if_port_busy(self, lport):
        if not self.disablePayloadHandler:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            try:
                s.bind(("0.0.0.0", int(lport)))
            except socket.error as e:
                if e.errno == errno.EADDRINUSE:
                    print_error("Port busy, please select another lport option")
                return False
        return True

    def _add_payload_option(self, payload):

        try:
            payload_path = pythonize_path(payload)
            module_path = ".".join(("modules", payload_path))
            try:
                module = getattr(importlib.import_module(module_path), "Module")()
                self._current_payload = module
            except ImportError:
                raise ProcedureError()
            for option in module.options:
                self._payload_options.append(option)
                self.exploit_attributes[option] = module.exploit_attributes[option]
                setattr(self, option, "{}".format(module.exploit_attributes[option][0]))
        except:
            print_error("Problem with payload")
            raise ProcedureError()