from kittysploit.core.framework.base_module import BaseModule
from kittysploit.core.framework.failure import ProcedureError, fail
from kittysploit.core.framework.option import OptBool, OptString, OptInteger, OptPayload
from kittysploit.core.base.io import print_info, print_error, print_status
from kittysploit.core.base.jobs import Jobs
from kittysploit.core.base.storage import LocalStorage
from kittysploit.core.base.timeout import timeout, TimeoutError
from kittysploit.core.utils.function_module import pythonize_path
import importlib
import time
import socket, errno
import threading


class Exploit(BaseModule):

    TYPE_MODULE = "exploit"

    session = OptInteger(0, "Session to interact with", required=True)
    payload = OptPayload("", "Payload type", required=True)

    exploit_timeout = OptInteger(20, "Timeout", required=True, advanced=True)
    disablePayloadHandler = OptBool(False, "Disable handler when exploit run", required=False, advanced=True)
    customPayload = OptString("","Execute module with custom payload (no listener start)",required=False,advanced=True,)

    def __init__(self):
        super(Exploit, self).__init__()
        self.job = Jobs()
        self.local_storage = LocalStorage()
        self.current_version = 0
        self._current_payload = None
        self._payload_options = []
        self._waiting_session = True

    def run(self):
        raise NotImplementedError("You have to define your own 'run' method.")

    def check(self):
        raise NotImplementedError("You have to define your own 'run' method.")

    def default_options(self):
        return False

    def _check_if_port_busy(self, lport):
        if not self.disablePayloadHandler:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            try:
                s.bind(("0.0.0.0", int(lport)))
            except socket.error as e:
                if e.errno == errno.EADDRINUSE:
                    print_error("Port busy, please select another lport option")
                return False
        return True

    def _exploit(self):

        if self._current_payload:
            if "handler" in self._current_payload._Module__info__:
                if self._check_if_port_busy(self.exploit_attributes["lport"][0]):
                    handler = self._current_payload._Module__info__["handler"]["name"]
                    if handler == "reverse":
                        setattr(self._current_payload,"lhost",self.exploit_attributes["lhost"][0],)
                        setattr(self._current_payload,"lport",self.exploit_attributes["lport"][0],)
                        if not self.disablePayloadHandler:
                            prepare_listener = pythonize_path(self._current_payload._Module__info__["listener"])
                            try:
                                listener = getattr(importlib.import_module("modules." + prepare_listener),"Module",)()
                            except:
                                print_error(f"Problem with: {self._current_payload._Module__info__['listener']}")
                                raise ProcedureError()
                            setattr(listener, "lhost", self.exploit_attributes["lhost"][0])
                            listener.exploit_attributes["lhost"][0] = (self.exploit_attributes["lhost"][0])
                            setattr(listener, "lport", self.exploit_attributes["lport"][0])
                            listener.exploit_attributes["lport"][0] = (self.exploit_attributes["lport"][0])
                            job_process = threading.Thread(target=listener._exploit, args=[])
                            job_process.setDaemon(True)
                            job_process.start()
                            if not self.local_storage.get("exploit_job"):
                                self.local_storage.set(
                                    "exploit_job",
                                    {"listener": listener, "thread": job_process},
                                )
                            time.sleep(1)

                        self.run()
                        print_status("Wait session...")
                        start_time = time.time()
                        while time.time() - start_time < self.exploit_timeout:
                            if LocalStorage().get(f"session_found") == True:
                                LocalStorage().delete("session_found")
                                return True
                            time.sleep(0.5)
                        time.sleep(0.5)
                        if self.local_storage.get(f"session_found") == None:
                            fail.NoSession
                            
                    if handler == "bind":
                        setattr(self._current_payload,"rhost",self.exploit_attributes["rhost"][0],)
                        setattr(self._current_payload,"rport",self.exploit_attributes["rport"][0],)                        
                        if not self.disablePayloadHandler:
                            self.run()
                            time.sleep(1)
                            prepare_listener = pythonize_path(self._current_payload._Module__info__["listener"])
                            try:
                                listener = getattr(importlib.import_module("modules." + prepare_listener),"Module",)()
                            except:
                                print_error(f"Problem with: {self._current_payload._Module__info__['listener']}")
                                raise ProcedureError()
                            setattr(listener, "rhost", self.exploit_attributes["rhost"][0])
                            listener.exploit_attributes["rhost"][0] = (self.exploit_attributes["rhost"][0])
                            setattr(listener, "rport", self.exploit_attributes["rport"][0])
                            listener.exploit_attributes["rport"][0] = (self.exploit_attributes["rport"][0])
                            listener._exploit()

        else:
            self.run()

    def _add_payload_option(self, payload):

        try:
            payload_path = pythonize_path(payload)
            module_path = ".".join(("modules", payload_path))
            try:
                module = getattr(importlib.import_module(module_path), "Module")()
                self._current_payload = module
            except ImportError:
                raise ProcedureError()
            for option in module.options:
                self._payload_options.append(option)
                self.exploit_attributes[option] = module.exploit_attributes[option]
                setattr(self, option, "{}".format(module.exploit_attributes[option][0]))
        except:
            print_error("Problem with payload")
            raise ProcedureError()
